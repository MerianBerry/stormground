#version 460 core

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

uniform float time;

void main() {
  ivec2 pix_coords = ivec2(gl_GlobalInvocationID.xy);

  ivec2 dims = imageSize(screen);
  float x = (float(pix_coords.x * 2 - dims.x) / dims.x);
  float y = -(float(pix_coords.y * 2 - dims.y) / dims.y);

  #if 1
  vec2 p1 = vec2(0.0, 0.5);
  vec2 p2 = vec2(1.0 - time, -0.5);
  vec2 p3 = vec2(-0.5, -0.5);
  vec2 vp = vec2(x, y);
  vec2 fp2 = p2 - p1;
  vec2 fp3 = p3 - p2;
  vec2 fp1 = p1 - p3;
  float d2 = dot(normalize(vec2(fp2.y, -fp2.x)), normalize(vp-p1));
  float d3 = dot(normalize(vec2(fp3.y, -fp3.x)), normalize(vp-p2));
  float d1 = dot(normalize(vec2(fp1.y, -fp1.x)), normalize(vp-p3));
  if (d2 > 0.0 && d3 > 0.0 && d1 > 0.0)
    imageStore(screen, pix_coords, vec4((x+1.0)/2.0, (y+1.0)/2.0, 1.0, 1.0));

  #else

  vec4 pixel = vec4(0.1, 0.1, 0.1, 1.0);

  float fov = 90.0;
  vec3 cam_o = vec3(0.0, 0.0, -tan(fov / 2.0));
  vec3 ray_o = vec3(x, y, 0.0);
  vec3 ray_d = normalize(ray_o - cam_o);

  vec3 sphere_c = vec3(0.0, 0.0, -5.0);
  float sphere_r = 1.0;
  
  vec3 o_c = ray_o - sphere_c;
  float b = dot(ray_d, o_c);
  float c = dot(o_c, o_c) - sphere_r * sphere_r;
  float intersectionState = b * b - c;
  vec3 intersection = ray_o + ray_d * (-b + sqrt(b * b - c));

  if (intersectionState >= 0.0) {
    pixel = vec4((normalize(intersection - sphere_c) + 1.0) / 2.0, 1.0);
  }

  imageStore(screen, pix_coords, pixel);
  #endif
}

